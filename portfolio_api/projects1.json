[{
  "title": "miniRT: Ray Tracing Engine",
  "slug": "minirt",
  "description": "A ray tracing renderer created in C that simulates how light interacts with 3D objects. This implementation follows ray tracing principles to generate photorealistic images with proper shadows, reflections, and lighting effects.",
  "readme": "<h1 align=\"center\">miniRT</h1>\n<h3 align=\"center\">42Paris School Project</h3>\n\n<p align=\"center\">\n  <img src=\"https://img.shields.io/badge/Language-C-blue.svg\" alt=\"Language\">\n  <img src=\"https://img.shields.io/badge/Score-125%25-brightgreen.svg\" alt=\"Score\">\n</p>\n\n<p align=\"center\">A ray tracing program that renders 3D scenes with realistic lighting and shadows</p>\n\n## Overview\n\n**miniRT** is a ray tracer written in C using the **MiniLibX** library. It renders 3D scenes by simulating how light interacts with geometric objects. This project implements fundamental computer graphics concepts including ray-object intersections, lighting models, shadows, and camera transformations.\n\n## Key Features\n\n- **Multiple Geometric Primitives**: Spheres, planes, cylinders, and cones\n- **Phong Reflection Model**: Ambient, diffuse, and specular lighting components\n- **Scene Description Files**: Parse scene configurations from .rt files\n- **Advanced Camera System**: Configurable field of view and positioning\n- **Shadow Casting**: Objects block light to create realistic shadows\n- **Matrix Transformations**: Rotation and translation of objects in 3D space\n- **Texture Mapping**: Basic texture support including checkerboard patterns\n- **Bump Mapping**: Surface normal perturbation for added realism\n\n## Technical Implementation\n\n- **Ray-Object Intersections**: Mathematical calculation of ray intersections with different shapes\n- **Vector Mathematics**: Complete vector library for 3D operations\n- **Matrix Operations**: 4x4 transformation matrices for objects and camera\n- **Lighting Algorithm**: Implementation of the Phong reflection model\n- **Shadow Calculation**: Shadow ray casting from intersection points to light sources\n- **Scene Parsing**: Robust parser for .rt scene description files\n\n## Usage\n\n```bash\n./miniRT scene_file.rt\n```\n\nThis project showcases my understanding of 3D graphics mathematics, C programming fundamentals, and complex algorithm implementation.",
  "tech_stack": ["C", "MiniLibX", "Ray Tracing", "3D Graphics", "Vector Mathematics", "Matrix Operations", "Phong Reflection Model"],
  "live_url": "",
  "code_url": "https://github.com/aouichou/miniRT",
  "is_featured": true,
  "score": 125,
  "features": [
    "Ray-object intersection calculation for spheres, planes, cylinders and cones",
    "Phong reflection model with ambient, diffuse, and specular components",
    "Shadow computation using ray casting techniques",
    "Camera system with adjustable field of view and positioning",
    "Matrix transformations for object translation and rotation",
    "Scene description file parser (.rt format)",
    "Texture mapping and basic pattern generation",
    "Bump mapping for surface normal perturbation",
    "Multi-light scene support with colored lighting",
    "Optimized render pipeline for better performance"
  ],
  "challenges": "The most challenging aspect was implementing the ray-object intersection mathematics, especially for complex shapes like cylinders and cones. Optimizing the renderer to handle scenes with multiple objects and lights required careful attention to computational efficiency. Another significant challenge was correctly implementing shadow calculations, which required tracing additional rays from intersection points to light sources while handling edge cases like self-shadowing.",
  "lessons": "This project deepened my understanding of 3D mathematics, particularly vector operations and transformation matrices. I gained practical experience implementing theoretical concepts like the Phong reflection model and ray-object intersections. The project taught me the importance of code organization in large C projects, as well as optimization techniques for computationally intensive applications. Working with scene description files improved my parsing and error handling skills.",
  "has_interactive_demo": false,
  "demo_commands": {
    "run": "./miniRT Scene_files/img17.rt",
    "run2": "./miniRT Scene_files/img08.rt",
    "compile": "make"
  },
  "code_steps": {
    "1": "Clone the repository",
    "2": "Run `make` to compile the renderer",
    "3": "Execute with a scene file: `./miniRT Scene_files/img08.rt`",
    "4": "Experiment with different scene files in the Scene_files directory",
    "5": "Create your own scene files following the .rt format"
  },
  "code_snippets": {
    "camera_system": {
      "language": "c",
      "filename": "camera.c",
      "code": "static void\tset_pixel_size(t_camera *camera)\n{\n\tfloat\thalf_view;\n\tfloat\taspect;\n\n\thalf_view = tanf(camera->field_of_view / 2);\n\taspect = camera->hsize / camera->vsize;\n\tif (aspect >= 1)\n\t{\n\t\tcamera->half_width = half_view;\n\t\tcamera->half_height = half_view / aspect;\n\t}\n\telse\n\t{\n\t\tcamera->half_width = half_view * aspect;\n\t\tcamera->half_height = half_view;\n\t}\n\tcamera->pixel_size = (camera->half_width * 2) / camera->hsize;\n}\n\nt_camera\t*camera(int hsize, int vsize, float field_of_view)\n{\n\tt_camera\t*cam;\n\n\tcam = malloc(sizeof(t_camera));\n\tif (!cam)\n\t\treturn (NULL);\n\tcam->hsize = hsize;\n\tcam->vsize = vsize;\n\tcam->field_of_view = field_of_view;\n\tcam->transform = identity_matrix();\n\tcam->inverse = identity_matrix();\n\tset_pixel_size(cam);\n\treturn (cam);\n}",
      "highlight_lines": [6, 7, 8, 10, 11, 15, 16, 18, 31, 32, 33, 34],
      "title": "Camera System Implementation",
      "description": "Calculates camera parameters for proper ray generation",
      "explanation": "This code implements the camera system for the ray tracer. It calculates the pixel size based on the field of view and aspect ratio to ensure proper ray generation for each pixel. The camera's transformation matrix determines its position and orientation in the scene. The half_width and half_height values represent the dimensions of the virtual viewport, which is placed at a distance of 1 unit from the camera. This implementation supports different image resolutions while maintaining the correct perspective."
    },
    "ray_sphere_intersection": {
      "language": "c",
      "filename": "sphere.c",
      "code": "static t_discriminant\tsphere_discriminant(t_object *obj, t_ray *ray)\n{\n\tt_discriminant\tdiscr;\n\tt_tuple\t\tsphere_to_ray;\n\t\n\tsphere_to_ray = subtract(ray->origin, obj->origin);\n\tdiscr.a = dot(ray->direction, ray->direction);\n\tdiscr.b = 2 * dot(ray->direction, sphere_to_ray);\n\tdiscr.c = dot(sphere_to_ray, sphere_to_ray) - 1;\n\tdiscr.discriminant = discr.b * discr.b - 4 * discr.a * discr.c;\n\treturn (discr);\n}\n\nt_intersect_list\t*intersect_sphere(t_object *obj, t_ray *ray)\n{\n\tt_ray\t\t\ttransformed_ray;\n\tt_discriminant\tdiscr;\n\tt_intersect_list\t*xs;\n\tfloat\t\t\tt[2];\n\n\ttransformed_ray = transform_ray(ray, obj->inverse);\n\tdiscr = sphere_discriminant(obj, &transformed_ray);\n\tif (discr.discriminant < 0)\n\t\treturn (NULL);\n\tt[0] = (-discr.b - sqrtf(discr.discriminant)) / (2 * discr.a);\n\tt[1] = (-discr.b + sqrtf(discr.discriminant)) / (2 * discr.a);\n\txs = intersect_list();\n\tif (!xs)\n\t\treturn (NULL);\n\tadd_intersection(xs, intersection(t[0], obj));\n\tadd_intersection(xs, intersection(t[1], obj));\n\treturn (xs);\n}",
      "highlight_lines": [6, 7, 8, 9, 10, 21, 22, 23, 24, 25, 26, 30, 31],
      "title": "Ray-Sphere Intersection",
      "description": "Calculates intersections between rays and spheres",
      "explanation": "This function calculates the intersections between a ray and a sphere using the quadratic formula. It first transforms the ray into the sphere's local coordinate system. Then it computes the discriminant of the quadratic equation to determine if there are any intersections. If the discriminant is negative, the ray misses the sphere. Otherwise, it calculates the two intersection points and returns them as an intersection list. This mathematical approach efficiently determines where rays hit spheres, which is fundamental to ray tracing."
    },
    "phong_lighting": {
      "language": "c",
      "filename": "lights.c",
      "code": "t_tuple\tlighting(t_material material, t_light *light, t_comp comp, bool in_shadow)\n{\n\tt_tuple\teffective_color;\n\tt_tuple\tambient;\n\tt_tuple\tdiffuse;\n\tt_tuple\tspecular;\n\tt_tuple\tlightv;\n\tt_tuple\treflectv;\n\tfloat\tlight_dot_normal;\n\tfloat\treflect_dot_eye;\n\tfloat\tfactor;\n\n\t// Combine surface color with light color\n\teffective_color = hadamard(get_color_at(material, comp.point), light->intensity);\n\t// Calculate the ambient contribution\n\tambient = scalar(effective_color, material.ambient);\n\tif (in_shadow)\n\t\treturn (ambient);\n\t// Calculate direction to light source\n\tlightv = normalize(subtract(light->position, comp.point));\n\t// Determine if light is on correct side\n\tlight_dot_normal = dot(lightv, comp.normalv);\n\tif (light_dot_normal < 0)\n\t{\n\t\tdiffuse = color(0, 0, 0);\n\t\tspecular = color(0, 0, 0);\n\t}\n\telse\n\t{\n\t\t// Calculate diffuse contribution\n\t\tdiffuse = scalar(effective_color, material.diffuse * light_dot_normal);\n\t\t// Calculate specular contribution\n\t\treflectv = reflect(negate(lightv), comp.normalv);\n\t\treflect_dot_eye = dot(reflectv, comp.eyev);\n\t\tif (reflect_dot_eye <= 0)\n\t\t\tspecular = color(0, 0, 0);\n\t\telse\n\t\t{\n\t\t\tfactor = powf(reflect_dot_eye, material.shininess);\n\t\t\tspecular = scalar(light->intensity, material.specular * factor);\n\t\t}\n\t}\n\treturn (add(ambient, add(diffuse, specular)));\n}",
      "highlight_lines": [14, 15, 16, 17, 18, 20, 21, 22, 23, 24, 30, 32, 33, 38, 39, 43],
      "title": "Phong Lighting Model",
      "description": "Calculates the color at a point using the Phong reflection model",
      "explanation": "This function implements the Phong reflection model, which calculates realistic lighting by combining ambient, diffuse, and specular components. Ambient lighting provides a base level of illumination. Diffuse lighting simulates light scattering on rough surfaces and depends on the angle between the light and surface normal. Specular highlights simulate the reflection of light sources and depend on the viewing angle. The function also handles shadows by returning only ambient light for shadowed points. This lighting model is essential for creating realistic-looking 3D renderings."
    },
    "shadow_calculation": {
      "language": "c",
      "filename": "shadow.c",
      "code": "bool\tis_shadowed(t_world *world, t_tuple point, t_light *light)\n{\n\tt_tuple\tv;\n\tfloat\tdistance;\n\tt_ray\t*r;\n\tt_intersect_list\t*intersections;\n\tt_intersection\t*h;\n\n\t// Vector from point to light\n\tv = subtract(light->position, point);\n\tdistance = magnitude(v);\n\t// Create a ray from point to light\n\tr = ray(point, normalize(v));\n\t// Find intersections between point and light\n\tintersections = intersect_world(world, r);\n\t// Check if any intersection blocks the light\n\th = hit(intersections);\n\t// Free resources\n\tfree_ray(r);\n\tfree_intersect_list(intersections);\n\t// Return true if there's a hit before the light source\n\treturn (h != NULL && h->t < distance);\n}",
      "highlight_lines": [10, 11, 13, 15, 17, 22],
      "title": "Shadow Calculation",
      "description": "Determines if a point is in shadow by tracing rays to light sources",
      "explanation": "This function determines if a point is in shadow by tracing a ray from the point toward the light source. If any object intersects this ray before reaching the light, the point is in shadow. The function calculates the vector from the point to the light, creates a ray in that direction, and checks for intersections with any objects in the world. It then compares the distance to any intersection with the distance to the light source. This shadow calculation is crucial for creating realistic scenes with proper lighting and depth."
    },
    "ray_generation": {
      "language": "c",
      "filename": "camera.c",
      "code": "t_ray\t*ray_for_pixel(t_camera *camera, int px, int py)\n{\n\tfloat\txoffset;\n\tfloat\tyoffset;\n\tfloat\tworld_x;\n\tfloat\tworld_y;\n\tt_tuple\tpixel;\n\tt_tuple\torigin;\n\tt_tuple\tdirection;\n\tt_ray\t*r;\n\n\t// Calculate the offset from the edge of the canvas to the pixel center\n\txoffset = (px + 0.5) * camera->pixel_size;\n\tyoffset = (py + 0.5) * camera->pixel_size;\n\t// Calculate the world coordinates of the pixel\n\tworld_x = camera->half_width - xoffset;\n\tworld_y = camera->half_height - yoffset;\n\t// Transform the canvas point and the origin using camera matrix\n\tpixel = multiply_matrix_tuple(camera->inverse, point(world_x, world_y, -1));\n\torigin = multiply_matrix_tuple(camera->inverse, point(0, 0, 0));\n\t// Calculate the ray direction vector and normalize it\n\tdirection = normalize(subtract(pixel, origin));\n\t// Create the ray\n\tr = ray(origin, direction);\n\treturn (r);\n}",
      "highlight_lines": [13, 14, 16, 17, 19, 20, 22, 24],
      "title": "Camera Ray Generation",
      "description": "Generates rays from the camera through each pixel of the viewport",
      "explanation": "This function generates rays from the camera through each pixel of the viewport, which is the first step in the ray tracing process. It calculates the world coordinates of the pixel based on its position in the image, the camera's field of view, and pixel size. It then applies the camera's transformation matrix to determine the ray's origin and direction in world space. The resulting ray is used to find intersections with objects in the scene. This precise ray generation is essential for creating accurate perspective rendering."
    },
    "matrix_transformations": {
      "language": "c",
      "filename": "matrices_transformations.c",
      "code": "t_matrix\t*translation(float x, float y, float z)\n{\n\tt_matrix\t*m;\n\n\tm = identity_matrix();\n\tm->data[0][3] = x;\n\tm->data[1][3] = y;\n\tm->data[2][3] = z;\n\treturn (m);\n}\n\nt_matrix\t*scaling(float x, float y, float z)\n{\n\tt_matrix\t*m;\n\n\tm = identity_matrix();\n\tm->data[0][0] = x;\n\tm->data[1][1] = y;\n\tm->data[2][2] = z;\n\treturn (m);\n}\n\nt_matrix\t*view_transform(t_tuple from, t_tuple to, t_tuple up)\n{\n\tt_tuple\tforward;\n\tt_tuple\tleft;\n\tt_tuple\ttrue_up;\n\tt_matrix\t*orientation;\n\tt_matrix\t*translation_matrix;\n\tt_matrix\t*result;\n\n\tforward = normalize(subtract(to, from));\n\tleft = cross(forward, normalize(up));\n\ttrue_up = cross(left, forward);\n\torientation = identity_matrix();\n\torientation->data[0][0] = left.x;\n\torientation->data[0][1] = left.y;\n\torientation->data[0][2] = left.z;\n\torientation->data[1][0] = true_up.x;\n\torientation->data[1][1] = true_up.y;\n\torientation->data[1][2] = true_up.z;\n\torientation->data[2][0] = -forward.x;\n\torientation->data[2][1] = -forward.y;\n\torientation->data[2][2] = -forward.z;\n\ttranslation_matrix = translation(-from.x, -from.y, -from.z);\n\tresult = multiply_matrices(orientation, translation_matrix);\n\tfree_matrix(orientation);\n\tfree_matrix(translation_matrix);\n\treturn (result);\n}",
      "highlight_lines": [5, 6, 7, 8, 16, 17, 18, 31, 32, 33, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46],
      "title": "3D Matrix Transformations",
      "description": "Creates transformation matrices for positioning objects and camera",
      "explanation": "This code implements 3D transformation matrices essential for computer graphics. The translation function creates a matrix that moves objects in 3D space. The scaling function creates a matrix that resizes objects. The view_transform function is particularly important as it creates a camera-to-world transformation matrix based on the camera's position (from), target point (to), and up direction. It constructs an orthonormal basis for the camera's coordinate system and combines it with a translation matrix. These transformation matrices allow objects and the camera to be positioned and oriented in the 3D scene."
    },
    "render_pipeline": {
      "language": "c",
      "filename": "render.c",
      "code": "void\trender(t_camera *camera, t_world *world, t_canvas *image)\n{\n\tt_ray\t*r;\n\tt_tuple\tcolor_val;\n\tint\tx;\n\tint\ty;\n\n\ty = 0;\n\twhile (y < camera->vsize)\n\t{\n\t\tx = 0;\n\t\twhile (x < camera->hsize)\n\t\t{\n\t\t\t// Generate ray through pixel\n\t\t\tr = ray_for_pixel(camera, x, y);\n\t\t\t// Calculate color at intersection\n\t\t\tcolor_val = color_at(world, r);\n\t\t\t// Set pixel in canvas\n\t\t\twrite_pixel(image, x, y, color_val);\n\t\t\t// Clean up ray\n\t\t\tfree_ray(r);\n\t\t\tx++;\n\t\t}\n\t\ty++;\n\t}\n}",
      "highlight_lines": [9, 10, 12, 15, 17, 19, 21],
      "title": "Render Pipeline",
      "description": "Main rendering loop that processes each pixel of the image",
      "explanation": "This function implements the main render pipeline, which is the heart of the ray tracer. For each pixel in the output image, it generates a ray from the camera through the pixel, calculates the color where the ray intersects objects in the world, and sets the pixel color accordingly. The nested loops iterate through every pixel of the canvas, while the ray_for_pixel function determines the ray's direction based on the camera parameters. The color_at function handles all the complex logic of finding intersections, calculating lighting, and determining shadows. This organized pipeline transforms the 3D scene description into a 2D image."
    },
    "scene_parser": {
      "language": "c",
      "filename": "scanner.c",
      "code": "static t_token\tidentify_token(char *line)\n{\n\tint\t\ti;\n\tt_token\ttoken;\n\n\ttoken.type = UNDEFINED;\n\ttoken.value = NULL;\n\tif (!line || line[0] == '\\0' || line[0] == '#')\n\t\treturn (token);\n\ttoken.value = trim(line);\n\tif (!token.value)\n\t\treturn (token);\n\ti = 0;\n\twhile (i < NUM_TOKEN_TYPES)\n\t{\n\t\tif (strncmp(token.value, g_token_types[i], \n\t\t\tstrlen(g_token_types[i])) == 0)\n\t\t{\n\t\t\ttoken.type = i;\n\t\t\tbreak ;\n\t\t}\n\t\ti++;\n\t}\n\treturn (token);\n}\n\nbool\tscan_file(t_world *world, char *filename)\n{\n\tint\t\tfd;\n\tchar\t*line;\n\tt_token\ttoken;\n\n\tif (!check_file_extension(filename, \".rt\"))\n\t\treturn (print_error(\"Invalid file extension\"));\n\tfd = open(filename, O_RDONLY);\n\tif (fd == -1)\n\t\treturn (print_error(\"Could not open file\"));\n\twhile (get_next_line(fd, &line))\n\t{\n\t\ttoken = identify_token(line);\n\t\tif (token.type != UNDEFINED)\n\t\t{\n\t\t\tif (!process_token(world, token))\n\t\t\t\treturn (false);\n\t\t}\n\t\tfree(token.value);\n\t\tfree(line);\n\t}\n\tclose(fd);\n\treturn (post_process_world(world));\n}",
      "highlight_lines": [8, 9, 10, 15, 16, 19, 33, 34, 35, 36, 37, 38, 41, 42, 44, 49],
      "title": "Scene File Parser",
      "description": "Parses .rt files to construct the 3D scene",
      "explanation": "This code implements a parser for .rt scene description files. The identify_token function analyzes each line to determine what type of scene element it describes (camera, light, sphere, etc.). The scan_file function reads the file line by line, identifies tokens, and processes them to construct the 3D world. It validates the file extension, handles errors gracefully, and ensures proper resource cleanup. After parsing all elements, post_process_world finalizes the scene setup. This robust parsing system allows users to create and modify scenes without changing the source code, making the ray tracer much more flexible and user-friendly."
    }
  },
  "galleries": [
    {
      "name": "Rendered Scenes",
      "description": "Various scenes rendered with the miniRT ray tracer",
      "order": 1,
      "images": [
        {
          "image": "projects/minirt/img08.png",
          "caption": "Simple sphere with directional lighting and proper shadows",
          "order": 1
        },
        {
          "image": "projects/minirt/img06.png",
          "caption": "Multiple spheres demonstrating shadow interaction",
          "order": 2
        },
        {
          "image": "projects/minirt/img10.png",
          "caption": "Camera positioning and perspective demonstration",
          "order": 3
        },
        {
          "image": "projects/minirt/img12.png",
          "caption": "Light intensity and reflection properties",
          "order": 4
        },
        {
          "image": "projects/minirt/img17.png",
          "caption": "Colored light sources producing mixed illumination",
          "order": 5
        }
      ]
    },
    {
      "name": "Advanced Features",
      "description": "Demonstration of special features and patterns",
      "order": 2,
      "images": [
        {
          "image": "projects/minirt/img14.png",
          "caption": "Multiple light sources creating complex shadows",
          "order": 1
        },
        {
          "image": "projects/minirt/img15.png",
          "caption": "Checkerboard pattern applied to the plane",
          "order": 2
        },
        {
          "image": "projects/minirt/img16.png",
          "caption": "Spheres with different pattern scales",
          "order": 3
        },
        {
          "image": "projects/minirt/img18.png",
          "caption": "Texture mapping applied to sphere surface",
          "order": 4
        },
        {
          "image": "projects/minirt/img19.png",
          "caption": "Bump mapping for detailed surface features",
          "order": 5
        }
      ]
    },
    {
      "name": "Interactive Demo",
      "description": "Runtime demonstration of the renderer",
      "order": 3,
      "images": [
        {
          "image": "projects/minirt/launch.gif",
          "caption": "Real-time rendering demonstration",
          "order": 1
        }
      ]
    }
  ],
  "thumbnail": "projects/minirt/img17.png",
  "architecture_diagram": "graph TD;\nA[Scene File] --> B[Scene Parser];\nB --> C[World Objects];\nC --> D[Ray Tracer];\nD --> E[Ray Generation];\nE --> F[Intersection Engine];\nF --> G[Lighting Calculation];\nG --> H[Shadow Calculation];\nG --> I[Image Output];\nI --> J[MiniLibX Display];",
  "diagram_type": "MERMAID"
},
{
  "title": "minishell",
  "slug": "minishell",
  "description": "A custom shell implementation in C, developed as part of the 42Paris curriculum. This project helped me appreciate the work done by the older generation of developers, gain a better understanding of how the shell works, and solidify my knowledge and skills in C and shell programming.",
  "readme": "<h1 align=\"center\">minishell</h1>\n<h3 align=\"center\">42Paris School Project</h3>\n\n<p align=\"center\">\n  <img src=\"https://img.shields.io/badge/Language-C-blue.svg\" alt=\"Language\">\n  <img src=\"https://img.shields.io/badge/Score-101%25-brightgreen.svg\" alt=\"Score\">\n</p>\n\n<p align=\"center\">A lightweight shell implementation focusing on core shell functionality and robust command processing</p>\n\n## Overview\n\n`minishell` is a custom shell implementation in C, developed as part of the 42Paris curriculum. This project replicates key features of bash, including command execution, built-in functions, signal handling, and pipeline processing. Implementing this project requires a deep understanding of process creation, file descriptor management, and command parsing.\n\n## Key Features\n\n- **Command Execution**: Run external commands with arguments through PATH lookup\n- **Built-in Commands**: Implementation of `echo`, `cd`, `pwd`, `export`, `unset`, `env`, and `exit`\n- **Signal Handling**: Proper management of SIGINT (Ctrl+C), SIGQUIT (Ctrl+\\), and others\n- **Redirection Support**: Input (`<`), output (`>`), append output (`>>`), and heredocs (`<<`)\n- **Pipeline Support**: Connect multiple commands with pipes (`|`)\n- **Environment Variables**: Full expansion including the special `$?` variable\n- **Command History**: Browse and reuse previous commands\n- **Quote Handling**: Proper parsing of single and double quotes\n\n## Technical Implementation\n\n- **Lexical Analysis**: Tokenization of input into meaningful command components\n- **Parser Construction**: Building a structured command representation from tokens\n- **Execution Engine**: Efficient handling of simple and complex commands\n- **Process Management**: Creating and managing child processes for execution\n- **Memory Management**: Careful allocation and deallocation to prevent leaks\n\n## Usage\n\n```bash\n./minishell\n```\n\nThis project demonstrates proficiency in low-level system programming, process management, and complex string parsing - skills essential for system-level software development.",
  "tech_stack": ["C", "Shell", "Unix", "Process Management", "File Descriptors", "Signal Handling", "Parser Construction"],
  "live_url": "",
  "code_url": "https://github.com/aouichou/minishell",
  "is_featured": true,
  "score": 101,
  "features": [
    "Display a prompt when waiting for a new command",
    "Working command history",
    "Execute commands based on the PATH variable or using relative/absolute paths",
    "Handle single and double quotes with appropriate rules",
    "Implement redirections (<, >, <<, >>)",
    "Implement pipes (|) for connecting multiple commands",
    "Handle environment variables and their expansion",
    "Manage signals like Ctrl-C, Ctrl-D, and Ctrl-\\",
    "Implement built-in commands (echo, cd, pwd, export, unset, env, exit)",
    "Return values and error handling with proper exit codes"
  ],
  "challenges": "The most challenging aspect of this project was implementing a robust parser that could correctly handle complex input with quotes, redirections, and pipes. Getting the lexical analysis right was crucial as it formed the foundation for everything else. Signal handling across processes also proved difficult, particularly ensuring that signals like Ctrl-C worked differently depending on whether the shell was waiting for input or executing a command. Properly managing file descriptors during redirections and making sure they were correctly restored after command execution required careful design.",
  "lessons": "This project significantly deepened my understanding of how shells work under the hood. I gained practical experience with process creation and management using fork() and execve(), learned the nuances of file descriptor manipulation, and developed a robust understanding of signal handling in a multi-process environment. The parser implementation taught me valuable lessons about grammar and tokenization in language processing. Overall, minishell helped me appreciate the complexity involved in tools we use daily and dramatically improved my C programming skills, particularly in memory management and system calls.",
  "has_interactive_demo": true,
  "demo_commands": {
    "run": "./minishell",
    "echo": "echo Hello World",
    "pipe": "ls -la | grep .c",
    "redir": "cat < input.txt > output.txt",
    "builtin": "cd .. && pwd"
  },
  "code_steps": {
    "1": "Clone the repository",
    "2": "Run `make` to compile the shell",
    "3": "Launch with `./minishell`",
    "4": "Try basic commands like `ls -la`, `echo Hello`, `pwd`",
    "5": "Test pipes: `ls | grep .c | wc -l`",
    "6": "Test redirections: `echo test > file.txt` and `cat < file.txt`",
    "7": "Try built-in commands like `cd`, `export`, `env`",
    "8": "Test signal handling with Ctrl+C, Ctrl+D, Ctrl+\\"
  },
  "code_snippets": {
    "lexical_analysis": {
      "language": "c",
      "filename": "lexer.c",
      "code": "t_token *tokenize_input(char *input)\n{\n\tt_token *tokens;\n\tint i;\n\tint j;\n\n\ttokens = NULL;\n\ti = 0;\n\twhile (input[i])\n\t{\n\t\tif (is_whitespace(input[i]))\n\t\t\ti++;\n\t\telse if (is_operator(input[i]))\n\t\t{\n\t\t\tj = get_operator_length(&input[i]);\n\t\t\tadd_token(&tokens, create_token(input + i, j, get_token_type(input + i, j)));\n\t\t\ti += j;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tj = get_word_length(&input[i]);\n\t\t\tadd_token(&tokens, create_token(input + i, j, WORD));\n\t\t\ti += j;\n\t\t}\n\t}\n\treturn (tokens);\n}",
      "highlight_lines": [11, 13, 15, 16, 21, 22],
      "title": "Lexical Analysis",
      "description": "Tokenizes user input into meaningful elements",
      "explanation": "This function implements a lexical analyzer (lexer) which breaks user input into tokens. It scans through the input character by character and classifies each segment as a word (command, argument), operator (pipe, redirection), or whitespace. The lexer intelligently handles special shell characters like quotes, ensuring that content inside quotes is treated properly. This tokenization is the first critical step in command processing, transforming raw input into structured elements that the parser can organize into executable commands."
    },
    "command_parsing": {
      "language": "c",
      "filename": "parser.c",
      "code": "t_cmd *parse_command(t_token *tokens)\n{\n\tt_cmd *command;\n\tt_token *current;\n\t\n\tif (!tokens)\n\t\treturn (NULL);\n\t\n\tcommand = init_cmd();\n\tif (!command)\n\t\treturn (NULL);\n\t\n\tcurrent = tokens;\n\twhile (current)\n\t{\n\t\tif (current->type == PIPE)\n\t\t{\n\t\t\tcommand->next = parse_command(current->next);\n\t\t\tbreak;\n\t\t}\n\t\telse if (is_redirection(current->type))\n\t\t{\n\t\t\tif (!handle_redirection(command, current))\n\t\t\t{\n\t\t\t\tfree_cmd(command);\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\tcurrent = current->next->next; // Skip redirection token and filename\n\t\t}\n\t\telse // Word token (command or argument)\n\t\t{\n\t\t\tadd_argument(command, current->value);\n\t\t\tcurrent = current->next;\n\t\t}\n\t}\n\t\n\treturn (command);\n}",
      "highlight_lines": [16, 17, 18, 19, 21, 23, 28, 31, 32],
      "title": "Command Parsing",
      "description": "Builds a structured command representation from tokens",
      "explanation": "The command parser processes the token stream to build a structured representation of the command. It identifies command boundaries (pipes), handles redirections, and collects command arguments. When it encounters a pipe, it recursively parses the next command in the pipeline. For redirections, it processes both the redirection operator and the associated filename. This structured representation enables the shell to correctly execute complex command sequences with pipes and redirections."
    },
    "builtin_command_handler": {
      "language": "c",
      "filename": "builtins.c",
      "code": "int\tcheck_builtin(t_cmd *cmd)\n{\n\tint\t\t\ti;\n\tsize_t\t\tz;\n\tstatic char\ttab[7][7] = {\"echo\", \"exit\", \"cd\", \"export\",\n\t\t\"unset\", \"env\", \"pwd\"};\n\n\ti = -1;\n\tif (!cmd || cmd->cmd_array == NULL)\n\t\treturn (0);\n\tif ((cmd->cmd_array && ft_strchr(*cmd->cmd_array, '/'))\n\t\t|| (cmd->path && ft_strchr(cmd->path, '/')))\n\t\treturn (0);\n\twhile (++i < 7)\n\t{\n\t\tz = ft_strlen(*cmd->cmd_array);\n\t\tif (ft_strlen(tab[i]) > z)\n\t\t\tz = ft_strlen(tab[i]);\n\t\tif (!ft_strncmp(*cmd->cmd_array, tab[i], z))\n\t\t\treturn (i + 1);\n\t}\n\treturn (0);\n}\n\nint\texecute_builtin(t_cmd *cmd, int type)\n{\n\tint\ti;\n\n\ti = 0;\n\tif (type == 1)\n\t\ti = ft_echo(cmd);\n\telse if (type == 2)\n\t\ti = ft_exit(cmd);\n\telse if (type == 3)\n\t\ti = ft_cd(cmd);\n\telse if (type == 4)\n\t\ti = ft_export(cmd);\n\telse if (type == 5)\n\t\ti = ft_unset(cmd);\n\telse if (type == 6)\n\t\ti = ft_env(cmd);\n\telse if (type == 7)\n\t\ti = ft_pwd(cmd);\n\treturn (i);\n}",
      "highlight_lines": [5, 6, 14, 19, 20, 30, 32, 34, 36, 38, 40, 42],
      "title": "Built-in Command Handler",
      "description": "Identifies and executes shell built-in commands",
      "explanation": "This code handles the identification and execution of built-in commands like 'echo', 'cd', and 'export'. The check_builtin function first determines whether a command is built-in by comparing it against a predefined list. If identified as a built-in, execute_builtin dispatches the command to its specific implementation function. Built-in commands are executed directly by the shell process rather than creating a new process, improving efficiency and allowing commands like 'cd' to affect the shell's environment."
    },
    "command_execution": {
      "language": "c",
      "filename": "execute.c",
      "code": "int\texecute_command(t_cmd *cmd)\n{\n\tint\ttype;\n\tint\tstatus;\n\tpid_t\tpid;\n\n\ttype = check_builtin(cmd);\n\tif (is_parent_builtin(type) && !cmd->next && cmd->prev == NULL)\n\t\treturn (execute_builtin(cmd, type));\n\n\tsignal(SIGINT, SIG_IGN);\n\tsignal(SIGQUIT, SIG_IGN);\n\tpid = fork();\n\tif (pid == -1)\n\t\treturn (print_error(\"fork\", NULL, 1));\n\tif (pid == 0)\n\t{\n\t\tsignal(SIGINT, SIG_DFL);\n\t\tsignal(SIGQUIT, SIG_DFL);\n\t\tprocess_redirections(cmd);\n\t\tif (cmd->prev)\n\t\t\tdup2(cmd->prev->pipe_fd[0], STDIN_FILENO);\n\t\tif (cmd->next)\n\t\t\tdup2(cmd->pipe_fd[1], STDOUT_FILENO);\n\t\tclose_pipes(cmd);\n\t\tif (type)\n\t\t\texit(execute_builtin(cmd, type));\n\t\telse if (cmd->path)\n\t\t\texecve(cmd->path, cmd->cmd_array, get_env_array());\n\t\texit(127);\n\t}\n\tif (cmd->prev)\n\t\tclose(cmd->prev->pipe_fd[0]);\n\tif (cmd->next)\n\t\tclose(cmd->pipe_fd[1]);\n\twaitpid(pid, &status, 0);\n\treturn (WEXITSTATUS(status));\n}",
      "highlight_lines": [7, 8, 9, 13, 16, 20, 22, 24, 26, 27, 29, 37],
      "title": "Command Execution Engine",
      "description": "Executes commands by creating child processes and handling I/O",
      "explanation": "This function implements the command execution logic, a critical part of the shell. For built-in commands that should run in the parent process, it executes them directly. For other commands, it creates a child process using fork() and then executes the command in that process. It carefully sets up input and output redirections, connects pipes between commands, and handles signal behavior differently for parent and child processes. After launching the command, it waits for completion and collects the exit status. This implementation demonstrates a deep understanding of process management and file descriptor manipulation in Unix systems."
    },
    "signal_handling": {
      "language": "c",
      "filename": "signals.c",
      "code": "void\thandler_sigint(int sig)\n{\n\t(void)sig;\n\tg_ms_data.exit_status = 128 + SIGINT;\n\twrite(2, \"\\n\", 1);\n\trl_replace_line(\"\", 0);\n\trl_on_new_line();\n\trl_redisplay();\n}\n\nvoid\thandler_sigquit(int sig)\n{\n\t(void)sig;\n}\n\nint\tset_interactive_signals(void)\n{\n\tstruct sigaction\tsa_int;\n\tstruct sigaction\tsa_quit;\n\n\tsigemptyset(&sa_int.sa_mask);\n\tsigemptyset(&sa_quit.sa_mask);\n\tsa_int.sa_handler = handler_sigint;\n\tsa_int.sa_flags = 0;\n\tsa_quit.sa_handler = handler_sigquit;\n\tsa_quit.sa_flags = 0;\n\tif (sigaction(SIGINT, &sa_int, NULL) == -1\n\t\t|| sigaction(SIGQUIT, &sa_quit, NULL) == -1)\n\t\treturn (print_error(\"sigaction\", NULL, 1));\n\treturn (0);\n}\n\nint\tset_noninteractive_signals(void)\n{\n\tsignal(SIGINT, SIG_DFL);\n\tsignal(SIGQUIT, SIG_DFL);\n\treturn (0);\n}",
      "highlight_lines": [4, 5, 6, 7, 8, 21, 22, 23, 24, 25, 26, 35, 36],
      "title": "Signal Handling",
      "description": "Manages signals like Ctrl-C and Ctrl-\\ appropriately",
      "explanation": "This code implements signal handling for the shell, differentiating between interactive mode (waiting for user input) and non-interactive mode (running commands). In interactive mode, SIGINT (Ctrl+C) is caught, displaying a new prompt instead of terminating the shell. SIGQUIT (Ctrl+\\) is silently ignored. In non-interactive mode, both signals are set to their default behavior. Using sigaction rather than simple signal handlers gives more control over how signals are processed. This careful signal handling is crucial for a shell to behave correctly in different contexts."
    },
    "environment_variable_management": {
      "language": "c",
      "filename": "env_tools.c",
      "code": "t_env\t*create_env_node(char *key, char *value)\n{\n\tt_env\t*node;\n\n\tnode = malloc(sizeof(t_env));\n\tif (!node)\n\t\treturn (NULL);\n\tnode->key = ft_strdup(key);\n\tif (!node->key)\n\t{\n\t\tfree(node);\n\t\treturn (NULL);\n\t}\n\tnode->value = NULL;\n\tif (value)\n\t{\n\t\tnode->value = ft_strdup(value);\n\t\tif (!node->value)\n\t\t{\n\t\t\tfree(node->key);\n\t\t\tfree(node);\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\tnode->next = NULL;\n\treturn (node);\n}\n\nvoid\tenv_add(t_env **env_list, char *key, char *value)\n{\n\tt_env\t*node;\n\tt_env\t*current;\n\n\tif (!env_list || !key)\n\t\treturn ;\n\tif (*env_list)\n\t{\n\t\tcurrent = find_env(*env_list, key);\n\t\tif (current)\n\t\t{\n\t\t\tif (current->value)\n\t\t\t\tfree(current->value);\n\t\t\tcurrent->value = value ? ft_strdup(value) : NULL;\n\t\t\treturn ;\n\t\t}\n\t}\n\tnode = create_env_node(key, value);\n\tif (!node)\n\t\treturn ;\n\tif (!*env_list)\n\t\t*env_list = node;\n\telse\n\t{\n\t\tcurrent = *env_list;\n\t\twhile (current->next)\n\t\t\tcurrent = current->next;\n\t\tcurrent->next = node;\n\t}\n}",
      "highlight_lines": [8, 14, 17, 29, 37, 41, 43, 47, 53],
      "title": "Environment Variable Management",
      "description": "Handles shell environment variables and their modifications",
      "explanation": "This code implements environment variable management for the shell. The create_env_node function allocates and initializes a new environment variable node with a key-value pair. The env_add function either updates an existing variable or adds a new one to the environment list. It first checks if the variable already exists and updates its value if it does. Otherwise, it creates a new node and adds it to the end of the list. This linked-list approach provides efficient variable lookup and modification, which is essential for commands like 'export' and environment variable expansion in commands."
    },
    "heredoc_handling": {
      "language": "c",
      "filename": "heredoc.c",
      "code": "int\theredoc(t_cmd *cmd, char *delim)\n{\n\tchar\t*line;\n\tint\t\tfd[2];\n\n\tif (pipe(fd) == -1)\n\t\treturn (-1);\n\twhile (1)\n\t{\n\t\tline = readline(\"> \");\n\t\tif (!line || !ft_strcmp(line, delim))\n\t\t{\n\t\t\tfree(line);\n\t\t\tbreak;\n\t\t}\n\t\twrite(fd[1], line, ft_strlen(line));\n\t\twrite(fd[1], \"\\n\", 1);\n\t\tfree(line);\n\t}\n\tclose(fd[1]);\n\tif (cmd->input_fd != STDIN_FILENO)\n\t\tclose(cmd->input_fd);\n\tcmd->input_fd = fd[0];\n\treturn (0);\n}",
      "highlight_lines": [6, 10, 11, 16, 17, 20, 23],
      "title": "Heredoc Implementation",
      "description": "Processes heredoc input (<<) for command input",
      "explanation": "This function implements the heredoc functionality (<<) in the shell, allowing multi-line input until a delimiter is encountered. It creates a pipe to store the input data and uses readline to gather each line from the user. Lines are written to the pipe until the delimiter is encountered. After collecting all input, the function sets the command's input file descriptor to read from the pipe. This implementation demonstrates understanding of both interactive input handling and file descriptor manipulation, providing a seamless experience for heredoc usage in commands."
    },
    "redirection_handling": {
      "language": "c",
      "filename": "get_fd.c",
      "code": "int\tprocess_redirections(t_cmd *cmd)\n{\n\tint\ti;\n\n\ti = -1;\n\tif (cmd->input_fd != STDIN_FILENO)\n\t{\n\t\tif (dup2(cmd->input_fd, STDIN_FILENO) == -1)\n\t\t\treturn (print_error(\"dup2\", NULL, 1));\n\t\tclose(cmd->input_fd);\n\t}\n\tif (cmd->output_fd != STDOUT_FILENO)\n\t{\n\t\tif (dup2(cmd->output_fd, STDOUT_FILENO) == -1)\n\t\t\treturn (print_error(\"dup2\", NULL, 1));\n\t\tclose(cmd->output_fd);\n\t}\n\twhile (cmd->fds && cmd->fds[++i] > 2)\n\t\tclose(cmd->fds[i]);\n\treturn (0);\n}\n\nint\topen_input_file(t_cmd *cmd, char *file)\n{\n\tint\tfd;\n\n\tfd = open(file, O_RDONLY);\n\tif (fd == -1)\n\t\treturn (print_error(file, NULL, 1));\n\tif (cmd->input_fd != STDIN_FILENO)\n\t\tclose(cmd->input_fd);\n\tcmd->input_fd = fd;\n\tcmd->fds = add_fd(cmd->fds, fd);\n\treturn (0);\n}\n\nint\topen_output_file(t_cmd *cmd, char *file, int append)\n{\n\tint\tfd;\n\tint\tflags;\n\n\tflags = O_WRONLY | O_CREAT;\n\tif (append)\n\t\tflags |= O_APPEND;\n\telse\n\t\tflags |= O_TRUNC;\n\tfd = open(file, flags, 0644);\n\tif (fd == -1)\n\t\treturn (print_error(file, NULL, 1));\n\tif (cmd->output_fd != STDOUT_FILENO)\n\t\tclose(cmd->output_fd);\n\tcmd->output_fd = fd;\n\tcmd->fds = add_fd(cmd->fds, fd);\n\treturn (0);\n}",
      "highlight_lines": [6, 8, 9, 10, 12, 14, 15, 16, 28, 31, 32, 33, 44, 45, 47, 49, 52, 53],
      "title": "Redirection Handling",
      "description": "Manages input and output redirections for commands",
      "explanation": "This code implements file redirection for shell commands. The process_redirections function sets up the standard input and output files for a command by duplicating the appropriate file descriptors. The open_input_file function handles input redirection (<), opening the specified file for reading. The open_output_file function handles output redirection (> and >>), with a flag to determine whether to append to or overwrite the file. Each function carefully manages file descriptors, ensuring they're properly tracked and closed when no longer needed to prevent resource leaks. This implementation demonstrates a thorough understanding of Unix file handling and descriptor management."
    }
  },
  "galleries": [
    {
      "name": "Shell Operation",
      "description": "Demonstration of minishell in action with various commands",
      "order": 1,
      "images": [
        {
          "image": "projects/minishell/demo.gif",
          "caption": "General demonstration of minishell capabilities",
          "order": 1
        },
        {
          "image": "projects/minishell/prompt.gif",
          "caption": "Interactive prompt with command history",
          "order": 2
        },
        {
          "image": "projects/minishell/commands.gif",
          "caption": "Various commands including pipes and redirections",
          "order": 3
        },
        {
          "image": "projects/minishell/Screenshot.png",
          "caption": "Shell features and error handling",
          "order": 4
        }
      ]
    }
  ],
  "thumbnail": "projects/minishell/Screenshot.png",
  "architecture_diagram": "graph TD;\nA[User Input] --> B[Lexer/Parser];\nB --> C{Command Type};\nC -->|Built-in| D[Execute Built-in];\nC -->|External| E[Fork Process];\nE --> F[execve()];\nD --> G[Return to Prompt];\nF --> G;\nB --> H[Process Redirections];\nH --> C;\nB --> I[Process Pipes];\nI --> J[Create Pipe FDs];\nJ --> E;",
  "diagram_type": "MERMAID"
},
{
  "title": "ft_transcendence: Real-time Multiplayer Pong",
  "slug": "ft_transcendence",
  "description": "A full-featured web application built around the classic game Pong, featuring real-time multiplayer matches, tournaments, user authentication with OAuth and 2FA, social features, and AI opponents. Developed as a team project with a microservices architecture using Django, Vue.js, and Docker.",
  "readme": "<h1 align=\"center\">ft_transcendence</h1>\n<h3 align=\"center\">42Paris School Project</h3>\n\n<p align=\"center\">\n  <img src=\"https://img.shields.io/badge/Frontend-Vue.js-42b883.svg\" alt=\"Frontend\">\n  <img src=\"https://img.shields.io/badge/Backend-Django-092e20.svg\" alt=\"Backend\">\n  <img src=\"https://img.shields.io/badge/Deployment-Docker-2496ed.svg\" alt=\"Deployment\">\n  <img src=\"https://img.shields.io/badge/Status-Production-brightgreen.svg\" alt=\"Status\">\n</p>\n\n<p align=\"center\">A full-featured web application centered around the classic game Pong with multiplayer capabilities and social features</p>\n\n## Overview\n\nft_transcendence is a comprehensive web application centered around the classic game Pong. It features real-time multiplayer gameplay, user authentication with OAuth and Two-Factor Authentication, tournament systems, and AI opponents. The application is built with a microservices architecture using Django for the backend, Vue.js for the frontend, and WebSockets for real-time communication.\n\n## Key Features\n\n- **Real-time Multiplayer Game**: Play Pong against other users with smooth, responsive gameplay\n- **Authentication System**: OAuth integration with 42's intranet and optional Two-Factor Authentication\n- **User Profiles**: Customizable avatars, game statistics, and achievements\n- **Tournament System**: Create and participate in Pong tournaments with bracket visualization\n- **Friend System**: Add friends, see their online status, and invite them to games\n- **Chat System**: Public channels, private messages, and moderation capabilities\n- **AI Opponents**: Practice against computer players with adjustable difficulty levels\n- **Responsive Design**: Optimized experience across desktop and mobile devices\n\n## Technical Implementation\n\n- **Frontend**: Vue.js with Vuex for state management and Vue Router for navigation\n- **Backend**: Django REST Framework with PostgreSQL database\n- **Real-time Communication**: WebSockets for game state and chat functionality\n- **Authentication**: JWT tokens, OAuth2 integration, and TOTP for 2FA\n- **Containerization**: Docker and Docker Compose for consistent development and deployment\n- **CI/CD**: Automated testing and deployment pipeline\n\nThis project demonstrates proficiency in full-stack development, real-time web applications, authentication systems, and containerized microservices architecture.",
  "tech_stack": ["Python", "Django", "Vue.js", "WebSockets", "PostgreSQL", "Docker", "Nginx", "JWT", "OAuth2", "TOTP"],
  "live_url": "https://transcendence.alexandrepayet.re/",
  "code_url": "https://github.com/aouichou/ft_transcendence",
  "is_featured": true,
  "score": 125,
  "features": [
    "Real-time multiplayer Pong game with WebSocket communication",
    "OAuth authentication with 42's intranet",
    "Two-Factor Authentication using TOTP",
    "Chat system with public channels and private messages",
    "Tournament system with brackets visualization",
    "Friend system with online status and game invitations",
    "User profiles with customizable avatars and statistics",
    "AI opponents with multiple difficulty levels",
    "Match history and detailed game statistics",
    "Responsive design for desktop and mobile",
    "Microservices architecture with Docker",
    "Admin dashboard for monitoring and moderation"
  ],
  "challenges": "The biggest challenge was implementing the real-time game engine with precise physics while ensuring a smooth experience across different network conditions. We had to carefully balance the client-server communication to minimize latency while maintaining game state consistency. Another significant challenge was orchestrating the microservices architecture, ensuring proper communication between containers and handling state management across services. Authentication presented unique challenges as we had to integrate with 42's OAuth system while also implementing our own 2FA solution and ensuring secure sessions throughout the application.",
  "lessons": "This project provided invaluable experience in developing full-stack applications with real-time capabilities. We gained expertise in WebSocket implementation for both game state synchronization and chat functionality. The team structure enhanced our collaboration skills, particularly in using Git for version control with multiple developers. Working with Docker for development and deployment gave us practical experience with containerization and microservices. The OAuth integration and 2FA implementation deepened our understanding of modern authentication flows and security best practices. Overall, this project demonstrated how to combine multiple technologies to create a cohesive, production-ready application.",
  "has_interactive_demo": true,
  "demo_commands": {
    "live_site": "https://transcendence.alexandrepayet.re/",
    "local_setup": "docker-compose up"
  },
  "code_steps": {
    "1": "Clone the repository: `git clone https://github.com/aouichou/ft_transcendence.git`",
    "2": "Create a `.env` file with necessary environment variables (see `.env.example`)",
    "3": "Run `docker-compose up --build` to build and start all services",
    "4": "Access the application at `http://localhost:3000`",
    "5": "Log in with 42 OAuth or create a local account for testing",
    "6": "Use the created account to explore game modes, tournaments, and social features"
  },
  "code_snippets": {
    "game_physics": {
      "language": "javascript",
      "filename": "game_engine.js",
      "code": "export class GameEngine {\n  constructor(gameState, settings) {\n    this.state = gameState;\n    this.settings = settings;\n    this.lastUpdate = Date.now();\n  }\n\n  update() {\n    const now = Date.now();\n    const deltaTime = (now - this.lastUpdate) / 1000; // Convert to seconds\n    this.lastUpdate = now;\n\n    // Update ball position\n    this.state.ball.x += this.state.ball.velocityX * deltaTime;\n    this.state.ball.y += this.state.ball.velocityY * deltaTime;\n\n    // Check for collisions with top and bottom walls\n    if (this.state.ball.y <= 0 || this.state.ball.y >= this.settings.canvasHeight) {\n      this.state.ball.velocityY = -this.state.ball.velocityY;\n      this.state.ball.y = Math.max(0, Math.min(this.state.ball.y, this.settings.canvasHeight));\n    }\n\n    // Check for collisions with paddles\n    this.checkPaddleCollision();\n\n    // Check for scoring\n    this.checkScoring();\n\n    return this.state;\n  }\n\n  checkPaddleCollision() {\n    // Left paddle collision\n    if (this.state.ball.velocityX < 0 &&\n        this.state.ball.x <= this.settings.paddleWidth &&\n        this.state.ball.y >= this.state.leftPaddle.y &&\n        this.state.ball.y <= this.state.leftPaddle.y + this.settings.paddleHeight) {\n      \n      // Calculate bounce angle based on where the ball hit the paddle\n      const hitPosition = (this.state.ball.y - this.state.leftPaddle.y) / this.settings.paddleHeight;\n      const bounceAngle = (hitPosition - 0.5) * Math.PI / 3; // -π/6 to π/6 range\n      \n      // Update velocity with increased speed\n      const speed = Math.sqrt(Math.pow(this.state.ball.velocityX, 2) + Math.pow(this.state.ball.velocityY, 2));\n      const newSpeed = speed * 1.05; // Increase speed by 5%\n      \n      this.state.ball.velocityX = Math.cos(bounceAngle) * newSpeed;\n      this.state.ball.velocityY = Math.sin(bounceAngle) * newSpeed;\n    }\n    \n    // Right paddle collision (similar logic)\n    if (this.state.ball.velocityX > 0 &&\n        this.state.ball.x >= this.settings.canvasWidth - this.settings.paddleWidth &&\n        this.state.ball.y >= this.state.rightPaddle.y &&\n        this.state.ball.y <= this.state.rightPaddle.y + this.settings.paddleHeight) {\n      \n      const hitPosition = (this.state.ball.y - this.state.rightPaddle.y) / this.settings.paddleHeight;\n      const bounceAngle = (hitPosition - 0.5) * Math.PI / 3; // -π/6 to π/6 range\n      \n      const speed = Math.sqrt(Math.pow(this.state.ball.velocityX, 2) + Math.pow(this.state.ball.velocityY, 2));\n      const newSpeed = speed * 1.05; // Increase speed by 5%\n      \n      this.state.ball.velocityX = -Math.cos(bounceAngle) * newSpeed;\n      this.state.ball.velocityY = Math.sin(bounceAngle) * newSpeed;\n    }\n  }\n\n  checkScoring() {\n    // Ball out of bounds on left side\n    if (this.state.ball.x < 0) {\n      this.state.scores.right += 1;\n      this.resetBall('right');\n    }\n    \n    // Ball out of bounds on right side\n    if (this.state.ball.x > this.settings.canvasWidth) {\n      this.state.scores.left += 1;\n      this.resetBall('left');\n    }\n  }\n\n  resetBall(direction) {\n    this.state.ball.x = this.settings.canvasWidth / 2;\n    this.state.ball.y = this.settings.canvasHeight / 2;\n    \n    const angle = ((Math.random() * Math.PI / 4) - Math.PI / 8) + (direction === 'left' ? Math.PI : 0);\n    const speed = this.settings.initialBallSpeed;\n    \n    this.state.ball.velocityX = Math.cos(angle) * speed;\n    this.state.ball.velocityY = Math.sin(angle) * speed;\n  }\n}",
      "highlight_lines": [11, 12, 13, 14, 16, 17, 18, 31, 32, 33, 34, 37, 38, 40, 42, 43, 44, 57, 58, 64, 65, 70, 71, 79, 80],
      "title": "Game Physics Engine",
      "description": "Real-time physics implementation for the Pong game",
      "explanation": "This class implements the core physics engine for the Pong game, handling ball movement, collisions, and scoring. The update method calculates the time elapsed since the last frame to ensure consistent game speed regardless of frame rate. The physics includes realistic paddle collisions where the ball's bounce angle depends on where it hits the paddle, adding strategic depth to gameplay. The engine also gradually increases ball speed after each paddle hit to create escalating difficulty. This time-based approach with delta time calculations ensures smooth gameplay across different devices and network conditions."
    },
    "websocket_game_service": {
      "language": "python",
      "filename": "game_consumer.py",
      "code": "import json\nimport asyncio\nfrom channels.generic.websocket import AsyncWebsocketConsumer\nfrom asgiref.sync import sync_to_async\nfrom django.db import transaction\nfrom .models import Game, GamePlayer, User\nfrom .game_engine import GameEngine\n\nclass GameConsumer(AsyncWebsocketConsumer):\n    async def connect(self):\n        self.game_id = self.scope['url_route']['kwargs']['game_id']\n        self.game_group_name = f'game_{self.game_id}'\n        self.user = self.scope['user']\n\n        # Join game group\n        await self.channel_layer.group_add(\n            self.game_group_name,\n            self.channel_name\n        )\n        \n        # Accept the connection\n        await self.accept()\n        \n        # Check if user is a player or spectator\n        is_player = await self.is_game_player()\n        if is_player:\n            await self.send(text_data=json.dumps({\n                'type': 'game_joined',\n                'role': 'player',\n                'player_id': str(self.user.id)\n            }))\n            \n            # Get or initialize game state\n            game_state = await self.get_game_state()\n            await self.channel_layer.group_send(\n                self.game_group_name,\n                {\n                    'type': 'game_state_update',\n                    'state': game_state\n                }\n            )\n        else:\n            await self.send(text_data=json.dumps({\n                'type': 'game_joined',\n                'role': 'spectator'\n            }))\n    \n    async def disconnect(self, close_code):\n        # Leave game group\n        await self.channel_layer.group_discard(\n            self.game_group_name,\n            self.channel_name\n        )\n        \n        # Handle player disconnection\n        is_player = await self.is_game_player()\n        if is_player:\n            await self.handle_player_disconnect()\n    \n    async def receive(self, text_data):\n        data = json.loads(text_data)\n        message_type = data.get('type')\n        \n        if message_type == 'paddle_move':\n            # Validate user is a player\n            is_player = await self.is_game_player()\n            if not is_player:\n                return\n            \n            # Update paddle position\n            position = data.get('position')\n            await self.update_paddle_position(position)\n            \n            # Broadcast the updated position\n            await self.channel_layer.group_send(\n                self.game_group_name,\n                {\n                    'type': 'paddle_position',\n                    'player_id': str(self.user.id),\n                    'position': position\n                }\n            )\n        \n        elif message_type == 'start_game':\n            # Only host can start game\n            is_host = await self.is_game_host()\n            if is_host:\n                await self.start_game()\n    \n    async def game_state_update(self, event):\n        # Send game state to the client\n        await self.send(text_data=json.dumps({\n            'type': 'game_state',\n            'state': event['state']\n        }))\n    \n    async def paddle_position(self, event):\n        # Send paddle position update to clients\n        await self.send(text_data=json.dumps({\n            'type': 'paddle_position',\n            'player_id': event['player_id'],\n            'position': event['position']\n        }))\n    \n    @sync_to_async\n    def is_game_player(self):\n        try:\n            return GamePlayer.objects.filter(game_id=self.game_id, user=self.user).exists()\n        except Exception:\n            return False\n    \n    @sync_to_async\n    def is_game_host(self):\n        try:\n            return Game.objects.filter(id=self.game_id, host=self.user).exists()\n        except Exception:\n            return False\n    \n    @sync_to_async\n    def get_game_state(self):\n        game = Game.objects.get(id=self.game_id)\n        # Construct and return game state\n        return {\n            'id': str(game.id),\n            'status': game.status,\n            'players': list(game.gameplayer_set.values('user__id', 'user__username', 'side')),\n            'scores': {'left': game.score_left, 'right': game.score_right},\n            'ball': {'x': game.ball_x, 'y': game.ball_y},\n            'leftPaddle': {'y': game.left_paddle_y},\n            'rightPaddle': {'y': game.right_paddle_y}\n        }\n    \n    @sync_to_async\n    def update_paddle_position(self, position):\n        with transaction.atomic():\n            game = Game.objects.get(id=self.game_id)\n            player = game.gameplayer_set.get(user=self.user)\n            \n            if player.side == 'left':\n                game.left_paddle_y = position\n            else:\n                game.right_paddle_y = position\n            game.save(update_fields=['left_paddle_y', 'right_paddle_y'])\n    \n    @sync_to_async\n    def handle_player_disconnect(self):\n        with transaction.atomic():\n            game = Game.objects.get(id=self.game_id)\n            if game.status == 'playing':\n                # Forfeit the game\n                game.status = 'finished'\n                player = game.gameplayer_set.get(user=self.user)\n                \n                if player.side == 'left':\n                    game.score_right = game.max_score  # Right player wins\n                else:\n                    game.score_left = game.max_score  # Left player wins\n                \n                game.save()\n    \n    async def start_game(self):\n        # Initialize and start the game\n        game_state = await self.initialize_game()\n        \n        # Notify all clients that the game is starting\n        await self.channel_layer.group_send(\n            self.game_group_name,\n            {\n                'type': 'game_state_update',\n                'state': game_state\n            }\n        )\n        \n        # Start the game loop\n        asyncio.create_task(self.game_loop())\n    \n    @sync_to_async\n    def initialize_game(self):\n        with transaction.atomic():\n            game = Game.objects.get(id=self.game_id)\n            game.status = 'playing'\n            game.ball_x = 400  # Center X\n            game.ball_y = 300  # Center Y\n            game.ball_velocity_x = 200  # Initial X velocity\n            game.ball_velocity_y = 0  # Initial Y velocity\n            game.save()\n            \n            return self.get_game_state_sync(game)\n    \n    def get_game_state_sync(self, game):\n        # Non-async version for use within @sync_to_async methods\n        return {\n            'id': str(game.id),\n            'status': game.status,\n            'players': [{'user_id': p.user.id, 'username': p.user.username, 'side': p.side} \n                       for p in game.gameplayer_set.select_related('user').all()],\n            'scores': {'left': game.score_left, 'right': game.score_right},\n            'ball': {'x': game.ball_x, 'y': game.ball_y, \n                    'velocityX': game.ball_velocity_x, 'velocityY': game.ball_velocity_y},\n            'leftPaddle': {'y': game.left_paddle_y},\n            'rightPaddle': {'y': game.right_paddle_y}\n        }\n    \n    async def game_loop(self):\n        # Main game loop, runs until game is finished\n        engine = GameEngine()\n        \n        while True:\n            # Get current game state\n            game = await self.get_game_sync()\n            \n            if game.status != 'playing':\n                break\n            \n            # Update game state using physics engine\n            game_state = self.get_game_state_sync(game)\n            updated_state = engine.update(game_state)\n            \n            # Save updated state to database\n            await self.save_game_state(updated_state)\n            \n            # Broadcast updated state to all clients\n            await self.channel_layer.group_send(\n                self.game_group_name,\n                {\n                    'type': 'game_state_update',\n                    'state': updated_state\n                }\n            )\n            \n            # Check for win condition\n            if updated_state['scores']['left'] >= game.max_score or \\\n               updated_state['scores']['right'] >= game.max_score:\n                await self.end_game()\n                break\n            \n            # Wait before next update (60 FPS)\n            await asyncio.sleep(1/60)\n    \n    @sync_to_async\n    def get_game_sync(self):\n        return Game.objects.get(id=self.game_id)\n    \n    @sync_to_async\n    def save_game_state(self, state):\n        with transaction.atomic():\n            game = Game.objects.get(id=self.game_id)\n            game.ball_x = state['ball']['x']\n            game.ball_y = state['ball']['y']\n            game.ball_velocity_x = state['ball']['velocityX']\n            game.ball_velocity_y = state['ball']['velocityY']\n            game.score_left = state['scores']['left']\n            game.score_right = state['scores']['right']\n            game.save()\n    \n    @sync_to_async\n    def end_game(self):\n        with transaction.atomic():\n            game = Game.objects.get(id=self.game_id)\n            game.status = 'finished'\n            game.save()\n            \n            # Update player stats, ELO, etc.\n            self.update_player_stats(game)\n    \n    def update_player_stats(self, game):\n        # Update player statistics based on game results\n        left_player = game.gameplayer_set.get(side='left').user\n        right_player = game.gameplayer_set.get(side='right').user\n        \n        # Determine winner\n        if game.score_left > game.score_right:\n            winner = left_player\n            loser = right_player\n        else:\n            winner = right_player\n            loser = left_player\n        \n        # Update statistics\n        winner.profile.games_won += 1\n        loser.profile.games_lost += 1\n        winner.profile.save()\n        loser.profile.save()\n        \n        # Could implement ELO rating system here",
      "highlight_lines": [10, 11, 12, 16, 17, 18, 21, 25, 26, 27, 28, 29, 30, 33, 34, 35, 36, 37, 38, 56, 57, 58, 59, 60, 62, 63, 64, 72, 73, 74, 75, 76, 77, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 186, 187, 188, 189],
      "title": "WebSocket Game Service",
      "description": "Real-time communication for multiplayer Pong game",
      "explanation": "This Django Channels consumer handles WebSocket connections for the multiplayer Pong game, enabling real-time communication between players and the server. It manages the game lifecycle from connection and initialization through gameplay to disconnection and game completion. When a player connects, the consumer validates their role, adds them to the appropriate channel group, and sends initial game state. During gameplay, it processes paddle movement commands from clients, updates the game state using the physics engine, and broadcasts updates to all connected clients. The game loop runs at 60 frames per second to provide smooth gameplay while maintaining state consistency across clients. The consumer also handles special cases like player disconnection (triggering forfeit) and game completion (updating player statistics)."
    },
    "two_factor_auth": {
      "language": "python",
      "filename": "two_factor_auth.py",
      "code": "import pyotp\nimport qrcode\nimport io\nimport base64\nfrom django.conf import settings\nfrom django.contrib.auth import get_user_model\nfrom rest_framework import status, viewsets, permissions\nfrom rest_framework.response import Response\nfrom rest_framework.decorators import action\nfrom .models import UserProfile\n\nUser = get_user_model()\n\nclass TwoFactorAuthViewSet(viewsets.ViewSet):\n    permission_classes = [permissions.IsAuthenticated]\n    \n    @action(detail=False, methods=['post'])\n    def enable(self, request):\n        \"\"\"Enable 2FA for the authenticated user\"\"\"\n        user = request.user\n        profile = UserProfile.objects.get(user=user)\n        \n        # Check if 2FA is already enabled\n        if profile.two_factor_enabled:\n            return Response({'error': '2FA is already enabled'}, \n                            status=status.HTTP_400_BAD_REQUEST)\n        \n        # Generate a new secret key\n        secret_key = pyotp.random_base32()\n        profile.two_factor_secret = secret_key\n        profile.save(update_fields=['two_factor_secret'])\n        \n        # Generate provisioning URI for QR code\n        totp = pyotp.TOTP(secret_key)\n        provisioning_uri = totp.provisioning_uri(\n            name=user.email,\n            issuer_name=settings.TWO_FACTOR_ISSUER\n        )\n        \n        # Generate QR code image\n        qr = qrcode.QRCode(\n            version=1,\n            error_correction=qrcode.constants.ERROR_CORRECT_L,\n            box_size=10,\n            border=4,\n        )\n        qr.add_data(provisioning_uri)\n        qr.make(fit=True)\n        \n        img = qr.make_image(fill_color=\"black\", back_color=\"white\")\n        buffer = io.BytesIO()\n        img.save(buffer, format=\"PNG\")\n        qr_code_base64 = base64.b64encode(buffer.getvalue()).decode()\n        \n        return Response({\n            'secret': secret_key,\n            'qr_code': f'data:image/png;base64,{qr_code_base64}'\n        })\n    \n    @action(detail=False, methods=['post'])\n    def verify(self, request):\n        \"\"\"Verify and activate 2FA with provided token\"\"\"\n        user = request.user\n        profile = UserProfile.objects.get(user=user)\n        token = request.data.get('token')\n        \n        if not token:\n            return Response({'error': 'Token is required'}, \n                            status=status.HTTP_400_BAD_REQUEST)\n        \n        # Verify the token\n        totp = pyotp.TOTP(profile.two_factor_secret)\n        if totp.verify(token):\n            profile.two_factor_enabled = True\n            profile.save(update_fields=['two_factor_enabled'])\n            return Response({'success': '2FA has been enabled'})\n        else:\n            return Response({'error': 'Invalid token'}, \n                            status=status.HTTP_400_BAD_REQUEST)\n    \n    @action(detail=False, methods=['post'])\n    def disable(self, request):\n        \"\"\"Disable 2FA for the authenticated user\"\"\"\n        user = request.user\n        profile = UserProfile.objects.get(user=user)\n        token = request.data.get('token')\n        \n        # Verify user with current token before disabling\n        if not profile.two_factor_enabled:\n            return Response({'error': '2FA is not enabled'}, \n                            status=status.HTTP_400_BAD_REQUEST)\n        \n        if not token:\n            return Response({'error': 'Token is required'}, \n                            status=status.HTTP_400_BAD_REQUEST)\n        \n        # Verify the token\n        totp = pyotp.TOTP(profile.two_factor_secret)\n        if totp.verify(token):\n            profile.two_factor_enabled = False\n            profile.two_factor_secret = \"\"\n            profile.save(update_fields=['two_factor_enabled', 'two_factor_secret'])\n            return Response({'success': '2FA has been disabled'})\n        else:\n            return Response({'error': 'Invalid token'}, \n                            status=status.HTTP_400_BAD_REQUEST)\n\n    @action(detail=False, methods=['post'])\n    def validate(self, request):\n        \"\"\"Validate a token for a user during login\"\"\"\n        user_id = request.data.get('user_id')\n        token = request.data.get('token')\n        \n        if not user_id or not token:\n            return Response({'error': 'User ID and token are required'}, \n                            status=status.HTTP_400_BAD_REQUEST)\n        \n        try:\n            user = User.objects.get(id=user_id)\n            profile = UserProfile.objects.get(user=user)\n            \n            if not profile.two_factor_enabled:\n                return Response({'error': '2FA is not enabled for this user'},\n                                status=status.HTTP_400_BAD_REQUEST)\n            \n            # Verify the token\n            totp = pyotp.TOTP(profile.two_factor_secret)\n            if totp.verify(token):\n                return Response({'success': True})\n            else:\n                return Response({'error': 'Invalid token'},\n                                status=status.HTTP_400_BAD_REQUEST)\n                \n        except User.DoesNotExist:\n            return Response({'error': 'User not found'},\n                            status=status.HTTP_404_NOT_FOUND)\n        except UserProfile.DoesNotExist:\n            return Response({'error': 'User profile not found'},\n                            status=status.HTTP_404_NOT_FOUND)",
      "highlight_lines": [16, 17, 18, 19, 20, 21, 22, 23, 24, 27, 28, 29, 31, 32, 33, 34, 35, 38, 39, 40, 41, 42, 43, 44, 45, 47, 48, 49, 50, 52, 53, 54, 55, 58, 59, 60, 61, 62, 63, 66, 67, 68, 69, 70, 71, 72, 94, 95, 96, 97, 98, 99, 100, 101, 118, 119, 120, 121, 122, 123],
      "title": "Two-Factor Authentication Implementation",
      "description": "TOTP-based two-factor authentication system",
      "explanation": "This code implements a complete two-factor authentication system using Time-based One-Time Passwords (TOTP) according to RFC 6238. The TwoFactorAuthViewSet provides endpoints to enable, verify, disable, and validate 2FA for users. When a user enables 2FA, the system generates a secure random secret key, creates a QR code for easy setup with authenticator apps like Google Authenticator, and stores the secret in the user's profile. The verification process validates the user-provided token against the stored secret, ensuring the authenticator app is correctly synchronized. During login, the validate endpoint verifies the submitted token, adding an extra security layer beyond passwords. The implementation follows security best practices with proper error handling and validation at each step."
    },
    "tournament_system": {
      "language": "python",
      "filename": "tournament.py",
      "code": "from django.db import models, transaction\nfrom django.utils import timezone\nfrom django.contrib.auth import get_user_model\nfrom django.core.validators import MinValueValidator, MaxValueValidator\nimport uuid\nimport random\n\nUser = get_user_model()\n\nclass Tournament(models.Model):\n    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)\n    name = models.CharField(max_length=100)\n    description = models.TextField(blank=True)\n    created_by = models.ForeignKey(User, on_delete=models.CASCADE, related_name='created_tournaments')\n    created_at = models.DateTimeField(auto_now_add=True)\n    start_time = models.DateTimeField()\n    status = models.CharField(max_length=20, choices=[\n        ('pending', 'Pending'),\n        ('registration', 'Registration Open'),\n        ('in_progress', 'In Progress'),\n        ('completed', 'Completed'),\n        ('cancelled', 'Cancelled')\n    ], default='pending')\n    max_participants = models.PositiveIntegerField(\n        validators=[MinValueValidator(4), MaxValueValidator(128)],\n        default=16\n    )\n    current_round = models.PositiveIntegerField(default=0)\n    \n    def __str__(self):\n        return f\"{self.name} ({self.get_status_display()})\"\n    \n    @property\n    def num_rounds(self):\n        \"\"\"Calculate number of rounds needed based on participant count\"\"\"\n        import math\n        return math.ceil(math.log2(self.max_participants))\n    \n    def start_tournament(self):\n        \"\"\"Start the tournament and generate first round matches\"\"\"\n        with transaction.atomic():\n            if self.status != 'registration':\n                raise ValueError(\"Tournament must be in registration status to start\")\n                \n            participants = list(self.participants.all())\n            if len(participants) < 4:\n                raise ValueError(\"Tournament needs at least 4 participants\")\n                \n            # Update tournament status\n            self.status = 'in_progress'\n            self.current_round = 1\n            self.save(update_fields=['status', 'current_round'])\n            \n            # Shuffle participants for randomized bracket\n            random.shuffle(participants)\n            \n            # Generate first round matches\n            self._generate_matches(participants)\n    \n    def _generate_matches(self, participants):\n        \"\"\"Generate matches for the current round\"\"\"\n        # If odd number of participants, add a bye\n        if len(participants) % 2 != 0:\n            participants.append(None)  # None represents a bye\n            \n        # Create matches\n        for i in range(0, len(participants), 2):\n            # Handle bye\n            if participants[i] is None or participants[i+1] is None:\n                player1 = participants[i] if participants[i] is not None else participants[i+1]\n                player2 = None\n                # Player with bye automatically advances\n                winner = player1\n                status = 'completed'\n            else:\n                player1 = participants[i]\n                player2 = participants[i+1]\n                winner = None\n                status = 'scheduled'\n                \n            TournamentMatch.objects.create(\n                tournament=self,\n                round=self.current_round,\n                player1=player1,\n                player2=player2,\n                status=status,\n                winner=winner\n            )\n    \n    def advance_round(self):\n        \"\"\"Advance to the next round of the tournament\"\"\"\n        with transaction.atomic():\n            # Check if current round is complete\n            incomplete_matches = self.matches.filter(\n                round=self.current_round, \n                status__in=['scheduled', 'in_progress']\n            )\n            \n            if incomplete_matches.exists():\n                raise ValueError(\"Cannot advance round until all matches are completed\")\n                \n            # Get winners from current round to create next round\n            winners = list(self.matches.filter(\n                round=self.current_round,\n                status='completed'\n            ).values_list('winner', flat=True))\n            \n            # If only one winner, tournament is complete\n            if len(winners) == 1:\n                self.status = 'completed'\n                self.save(update_fields=['status'])\n                return\n                \n            # Advance to next round\n            self.current_round += 1\n            self.save(update_fields=['current_round'])\n            \n            # Generate matches for new round\n            winners = [User.objects.get(id=w) for w in winners if w is not None]\n            self._generate_matches(winners)\n\nclass TournamentParticipant(models.Model):\n    tournament = models.ForeignKey(Tournament, on_delete=models.CASCADE, related_name='participants')\n    user = models.ForeignKey(User, on_delete=models.CASCADE)\n    registered_at = models.DateTimeField(auto_now_add=True)\n    seed = models.PositiveIntegerField(null=True, blank=True)  # For seeded tournaments\n    \n    class Meta:\n        unique_together = [['tournament', 'user']]\n        \n    def __str__(self):\n        return f\"{self.user.username} in {self.tournament.name}\"\n\nclass TournamentMatch(models.Model):\n    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)\n    tournament = models.ForeignKey(Tournament, on_delete=models.CASCADE, related_name='matches')\n    round = models.PositiveIntegerField()\n    player1 = models.ForeignKey(User, on_delete=models.CASCADE, related_name='tournament_matches_as_player1', null=True)\n    player2 = models.ForeignKey(User, on_delete=models.CASCADE, related_name='tournament_matches_as_player2', null=True)\n    status = models.CharField(max_length=20, choices=[\n        ('scheduled', 'Scheduled'),\n        ('in_progress', 'In Progress'),\n        ('completed', 'Completed')\n    ], default='scheduled')\n    winner = models.ForeignKey(User, on_delete=models.CASCADE, related_name='tournament_matches_won', null=True)\n    loser = models.ForeignKey(User, on_delete=models.CASCADE, related_name='tournament_matches_lost', null=True)\n    score_player1 = models.PositiveIntegerField(default=0)\n    score_player2 = models.PositiveIntegerField(default=0)\n    scheduled_time = models.DateTimeField(null=True, blank=True)\n    completed_time = models.DateTimeField(null=True, blank=True)\n    \n    class Meta:\n        ordering = ['round', 'scheduled_time']\n        \n    def __str__(self):\n        status_str = f\"[{self.get_status_display()}]\"\n        if self.player1 and self.player2:\n            return f\"{status_str} {self.player1.username} vs {self.player2.username} (Round {self.round})\"\n        elif self.player1:\n            return f\"{status_str} {self.player1.username} - Bye (Round {self.round})\"\n        else:\n            return f\"{status_str} TBD vs TBD (Round {self.round})\"\n    \n    def complete_match(self, score_player1, score_player2):\n        \"\"\"Complete a match with the given scores\"\"\"\n        with transaction.atomic():\n            if self.status == 'completed':\n                raise ValueError(\"Match already completed\")\n                \n            if not self.player1 or not self.player2:\n                raise ValueError(\"Cannot complete match without two players\")\n                \n            # Set scores\n            self.score_player1 = score_player1\n            self.score_player2 = score_player2\n            \n            # Determine winner and loser\n            if score_player1 > score_player2:\n                self.winner = self.player1\n                self.loser = self.player2\n            else:\n                self.winner = self.player2\n                self.loser = self.player1\n                \n            # Mark match as completed\n            self.status = 'completed'\n            self.completed_time = timezone.now()\n            self.save()\n            \n            # Check if round is complete and can advance\n            tournament = self.tournament\n            incomplete_matches = tournament.matches.filter(\n                round=tournament.current_round, \n                status__in=['scheduled', 'in_progress']\n            ).count()\n            \n            if incomplete_matches == 0:\n                # All matches in this round are complete\n                # Check if we should automatically advance the round\n                try:\n                    tournament.advance_round()\n                except ValueError:\n                    pass  # Silently ignore if not ready to advance\n\ndef generate_tournament_bracket(tournament_id):\n    \"\"\"Generate a full bracket structure for tournament visualization\"\"\"\n    tournament = Tournament.objects.get(id=tournament_id)\n    num_rounds = tournament.num_rounds\n    \n    # Create the bracket structure\n    bracket = {\n        'rounds': []\n    }\n    \n    # Get all matches for the tournament\n    matches = TournamentMatch.objects.filter(tournament=tournament).order_by('round', 'id')\n    \n    # Group matches by round\n    for round_num in range(1, num_rounds + 1):\n        round_matches = matches.filter(round=round_num)\n        \n        matches_data = []\n        for match in round_matches:\n            match_data = {\n                'id': str(match.id),\n                'player1': match.player1.username if match.player1 else 'TBD',\n                'player2': match.player2.username if match.player2 else 'TBD',\n                'score1': match.score_player1,\n                'score2': match.score_player2,\n                'winner': match.winner.username if match.winner else None,\n                'status': match.status\n            }\n            matches_data.append(match_data)\n        \n        # Add the round to the bracket structure\n        bracket['rounds'].append({\n            'round': round_num,\n            'name': f\"Round {round_num}\" if round_num < num_rounds else \"Final\",\n            'matches': matches_data\n        })\n    \n    return bracket",
      "highlight_lines": [10, 11, 12, 13, 14, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 121, 122, 123, 124, 125, 126, 127, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 186, 187, 195, 196, 197, 198],
      "title": "Tournament System",
      "description": "Complete tournament bracket generation and management",
      "explanation": "This tournament system implements a complete bracket-based competition structure with single-elimination rounds. The Tournament model tracks overall status, participants, and progression through rounds. When a tournament starts, it shuffles participants for fairness and generates first-round matches. As matches complete, winners advance to subsequent rounds until a final champion emerges. The system handles edge cases like byes (when participant numbers aren't powers of 2) and automatically advances players without opponents. The generate_tournament_bracket function creates a structured representation of the entire bracket for frontend visualization, showing completed matches, upcoming matches, and tournament progression. This implementation supports various tournament sizes (4-128 participants) and includes features like match scheduling, score tracking, and tournament lifecycle management."
    },
    "oauth_integration": {
      "language": "python",
      "filename": "oauth_views.py",
      "code": "import requests\nimport os\nimport json\nfrom django.conf import settings\nfrom django.contrib.auth import get_user_model, login\nfrom django.shortcuts import redirect\nfrom django.urls import reverse\nfrom django.http import JsonResponse\nfrom rest_framework import status\nfrom rest_framework.views import APIView\nfrom rest_framework.response import Response\nfrom rest_framework_simplejwt.tokens import RefreshToken\nfrom rest_framework.permissions import AllowAny\nfrom .models import UserProfile\n\nUser = get_user_model()\n\nclass OAuth42LoginView(APIView):\n    permission_classes = [AllowAny]\n    \n    def get(self, request):\n        \"\"\"Initiate OAuth2 flow with 42's API\"\"\"\n        # Build authorization URL for 42's OAuth\n        oauth_url = f\"{settings.OAUTH42_AUTHORIZATION_URL}\"\n        client_id = settings.OAUTH42_CLIENT_ID\n        redirect_uri = settings.OAUTH42_REDIRECT_URI\n        \n        # Define desired scopes\n        scope = \"public\"\n        \n        # Construct the full authorization URL\n        auth_url = f\"{oauth_url}?client_id={client_id}&redirect_uri={redirect_uri}&scope={scope}&response_type=code\"\n        \n        # Redirect user to 42's authorization endpoint\n        return Response({'auth_url': auth_url})\n\nclass OAuth42CallbackView(APIView):\n    permission_classes = [AllowAny]\n    \n    def get(self, request):\n        \"\"\"Handle callback from 42's OAuth service\"\"\"\n        # Get authorization code from query parameters\n        code = request.query_params.get('code')\n        error = request.query_params.get('error')\n        \n        if error:\n            return Response({'error': error}, status=status.HTTP_400_BAD_REQUEST)\n        \n        if not code:\n            return Response({'error': 'Authorization code not provided'}, \n                            status=status.HTTP_400_BAD_REQUEST)\n        \n        # Exchange authorization code for access token\n        token_data = self._get_access_token(code)\n        if not token_data or 'error' in token_data:\n            return Response({'error': 'Failed to obtain access token'}, \n                            status=status.HTTP_400_BAD_REQUEST)\n        \n        # Get user info using the access token\n        user_info = self._get_user_info(token_data['access_token'])\n        if not user_info or 'error' in user_info:\n            return Response({'error': 'Failed to obtain user information'}, \n                            status=status.HTTP_400_BAD_REQUEST)\n        \n        # Find or create user\n        user, created = self._get_or_create_user(user_info)\n        \n        # Generate JWT tokens\n        refresh = RefreshToken.for_user(user)\n        jwt_token = str(refresh.access_token)\n        \n        # Prepare response data\n        response_data = {\n            'access_token': jwt_token,\n            'refresh_token': str(refresh),\n            'user_id': user.id,\n            'username': user.username,\n            'email': user.email,\n            'is_new_user': created,\n            'two_factor_required': user.profile.two_factor_enabled\n        }\n        \n        # If 2FA is enabled, we return a temporary token that will need to be\n        # validated with a 2FA code before full authentication\n        if user.profile.two_factor_enabled:\n            response_data['auth_status'] = 'two_factor_required'\n        else:\n            response_data['auth_status'] = 'authenticated'\n        \n        # Return response with tokens and user info\n        return Response(response_data)\n    \n    def _get_access_token(self, code):\n        \"\"\"Exchange authorization code for access token\"\"\"\n        token_url = settings.OAUTH42_TOKEN_URL\n        client_id = settings.OAUTH42_CLIENT_ID\n        client_secret = settings.OAUTH42_CLIENT_SECRET\n        redirect_uri = settings.OAUTH42_REDIRECT_URI\n        \n        # Prepare token request data\n        token_data = {\n            'grant_type': 'authorization_code',\n            'client_id': client_id,\n            'client_secret': client_secret,\n            'code': code,\n            'redirect_uri': redirect_uri\n        }\n        \n        # Make POST request to token endpoint\n        response = requests.post(token_url, data=token_data)\n        \n        # Check response\n        try:\n            return response.json()\n        except json.JSONDecodeError:\n            return {'error': 'Invalid response from token endpoint'}\n    \n    def _get_user_info(self, access_token):\n        \"\"\"Get user info from 42's API using access token\"\"\"\n        user_info_url = settings.OAUTH42_USER_INFO_URL\n        headers = {'Authorization': f'Bearer {access_token}'}\n        \n        # Make GET request to user info endpoint\n        response = requests.get(user_info_url, headers=headers)\n        \n        # Check response\n        try:\n            return response.json()\n        except json.JSONDecodeError:\n            return {'error': 'Invalid response from user info endpoint'}\n    \n    def _get_or_create_user(self, user_info):\n        \"\"\"Find or create a user based on 42's user info\"\"\"\n        # Extract relevant user information\n        intra_id = user_info['id']\n        email = user_info['email']\n        username = user_info['login']\n        first_name = user_info['first_name']\n        last_name = user_info['last_name']\n        avatar_url = user_info['image']['link']\n        \n        try:\n            # Try to find existing user by intra ID\n            profile = UserProfile.objects.get(intra_id=intra_id)\n            user = profile.user\n            created = False\n            \n            # Update user information in case it changed\n            if user.email != email:\n                user.email = email\n            if user.first_name != first_name:\n                user.first_name = first_name\n            if user.last_name != last_name:\n                user.last_name = last_name\n            user.save()\n            \n            # Update profile information\n            if profile.avatar_url != avatar_url:\n                profile.avatar_url = avatar_url\n                profile.save()\n                \n        except UserProfile.DoesNotExist:\n            # Create new user and profile\n            user = User.objects.create(\n                username=username,\n                email=email,\n                first_name=first_name,\n                last_name=last_name,\n                # Password is not used for OAuth users, but set a random one for security\n                password=User.objects.make_random_password()\n            )\n            \n            # Create profile with intra ID\n            profile = UserProfile.objects.create(\n                user=user,\n                intra_id=intra_id,\n                avatar_url=avatar_url,\n                # Set default profile fields\n                display_name=username,\n                is_oauth_user=True\n            )\n            \n            created = True\n            \n        return user, created",
      "highlight_lines": [18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 98, 99, 100, 101, 102, 104, 105, 106, 107, 108, 109, 110, 112, 113, 116, 117, 118, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175],
      "title": "OAuth2 Integration with 42 API",
      "description": "Implementation of secure OAuth2 authentication flow with 42's API",
      "explanation": "This code implements a complete OAuth2 authentication flow with 42's intranet API, allowing users to authenticate using their 42 account. The OAuth42LoginView initiates the flow by redirecting users to 42's authorization page. When users approve access, they're redirected back to OAuth42CallbackView with an authorization code. This code is exchanged for an access token through a secure server-to-server request, maintaining client secret security. The access token retrieves the user's profile information from 42's API, which is then used to find or create a user account in the application. The integration handles both new and returning users, updating profile information as needed. It also integrates with the two-factor authentication system, requiring 2FA verification before granting full access to secured users. JSON Web Tokens (JWTs) are issued for authenticated sessions, providing secure, stateless authentication for subsequent API requests."
    },
    "ai_opponent": {
      "language": "javascript",
      "filename": "ai_opponent.js",
      "code": "export class AIOpponent {\n  constructor(difficulty = 'medium', gameState, settings) {\n    this.difficulty = difficulty; // 'easy', 'medium', 'hard'\n    this.gameState = gameState;\n    this.settings = settings;\n    this.paddleHeight = settings.paddleHeight;\n    this.canvasHeight = settings.canvasHeight;\n    this.reactionDelay = this._getReactionDelay();\n    this.lastMoveTime = Date.now();\n    this.targetPosition = null;\n    \n    // Error margin for hard AI not being perfect\n    this.predictionError = this._getPredictionError();\n    \n    // For easy AI: randomness in movement\n    this.randomFactor = this._getRandomFactor();\n    this.lastRandomChange = Date.now();\n    this.randomChangeInterval = 500; // Change direction every 500ms for easy AI\n    \n    // For medium AI: how far ahead to look\n    this.lookAheadFactor = this._getLookAheadFactor();\n  }\n  \n  _getReactionDelay() {\n    // Delay in milliseconds before AI reacts\n    switch (this.difficulty) {\n      case 'easy': return 300;\n      case 'medium': return 150;\n      case 'hard': return 30;\n      default: return 150;\n    }\n  }\n  \n  _getPredictionError() {\n    // Error margin in prediction (pixels)\n    switch (this.difficulty) {\n      case 'easy': return 60;\n      case 'medium': return 20;\n      case 'hard': return 5;\n      default: return 20;\n    }\n  }\n  \n  _getRandomFactor() {\n    // Random movement factor for easy AI\n    switch (this.difficulty) {\n      case 'easy': return 0.7;\n      case 'medium': return 0.3;\n      case 'hard': return 0;\n      default: return 0.3;\n    }\n  }\n  \n  _getLookAheadFactor() {\n    // How far ahead in time the AI predicts (milliseconds)\n    switch (this.difficulty) {\n      case 'easy': return 100;\n      case 'medium': return 500;\n      case 'hard': return 1000;\n      default: return 500;\n    }\n  }\n  \n  update() {\n    const ball = this.gameState.ball;\n    let paddleY;\n    \n    // Determine which paddle to control based on the ball's direction\n    if (ball.velocityX > 0) {\n      // Ball is moving toward right paddle\n      paddleY = this.gameState.rightPaddle.y;\n    } else {\n      // Ball is moving toward left paddle\n      paddleY = this.gameState.leftPaddle.y;\n    }\n    \n    const now = Date.now();\n    \n    // Easy AI: Add randomness periodically\n    if (this.difficulty === 'easy' && now - this.lastRandomChange > this.randomChangeInterval) {\n      this.lastRandomChange = now;\n      if (Math.random() < this.randomFactor) {\n        // Move randomly sometimes\n        return Math.random() * this.canvasHeight;\n      }\n    }\n    \n    // Calculate where the ball will intersect with the paddle's x-coordinate\n    if (now - this.lastMoveTime > this.reactionDelay) {\n      this.lastMoveTime = now;\n      this.targetPosition = this._predictBallPosition();\n      \n      // Add error based on difficulty\n      const error = (Math.random() * 2 - 1) * this.predictionError;\n      this.targetPosition = Math.max(0, Math.min(this.canvasHeight - this.paddleHeight, this.targetPosition + error));\n    }\n    \n    // Return current target position\n    return this.targetPosition;\n  }\n  \n  _predictBallPosition() {\n    const ball = this.gameState.ball;\n    const paddleX = ball.velocityX > 0 ? this.settings.canvasWidth - this.settings.paddleWidth : this.settings.paddleWidth;\n    \n    // If ball is moving away from this paddle, just track the center\n    if ((ball.velocityX > 0 && paddleX < ball.x) || (ball.velocityX < 0 && paddleX > ball.x)) {\n      return (this.canvasHeight - this.paddleHeight) / 2;\n    }\n    \n    // Calculate time until ball reaches paddle\n    const distanceToTravel = Math.abs(paddleX - ball.x);\n    const timeToReach = distanceToTravel / Math.abs(ball.velocityX);\n    \n    // Predict position based on difficulty level\n    const lookAheadTime = Math.min(timeToReach, this.lookAheadFactor / 1000);\n    \n    // Calculate where ball will be after look-ahead time\n    let futureY = ball.y + ball.velocityY * lookAheadTime;\n    \n    // Account for bounces off top and bottom walls\n    const bounceCount = Math.floor(futureY / this.settings.canvasHeight);\n    if (bounceCount % 2 === 0) {\n      futureY = futureY % this.settings.canvasHeight;\n    } else {\n      futureY = this.settings.canvasHeight - (futureY % this.settings.canvasHeight);\n    }\n    \n    // Return position, adjusted to center paddle on ball\n    return Math.max(0, Math.min(this.canvasHeight - this.paddleHeight, futureY - this.paddleHeight / 2));\n  }\n  \n  // Advanced prediction for hard difficulty\n  _predictBallPath() {\n    if (this.difficulty !== 'hard') return this._predictBallPosition();\n    \n    const ball = this.gameState.ball;\n    const paddleX = ball.velocityX > 0 ? this.settings.canvasWidth - this.settings.paddleWidth : this.settings.paddleWidth;\n    \n    // Clone ball properties to simulate future movement\n    let simulatedBall = {\n      x: ball.x,\n      y: ball.y,\n      velocityX: ball.velocityX,\n      velocityY: ball.velocityY\n    };\n    \n    // Simulate ball movement until it reaches paddle X position\n    while ((ball.velocityX > 0 && simulatedBall.x < paddleX) || \n           (ball.velocityX < 0 && simulatedBall.x > paddleX)) {\n      // Update simulated ball position\n      simulatedBall.x += simulatedBall.velocityX * 0.016; // Assuming 60 FPS (16ms)\n      simulatedBall.y += simulatedBall.velocityY * 0.016;\n      \n      // Check for collision with top/bottom walls\n      if (simulatedBall.y <= 0 || simulatedBall.y >= this.settings.canvasHeight) {\n        simulatedBall.velocityY *= -1; // Reverse Y velocity on collision\n      }\n    }\n    \n    // Return predicted position, adjusted to center paddle on ball\n    return Math.max(0, Math.min(this.canvasHeight - this.paddleHeight, simulatedBall.y - this.paddleHeight / 2));\n  }\n}\n",
	  "highlight_lines": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41],
	  "title": "AI Opponent Logic",
	  "description": "AI opponent logic for a Pong game with different difficulty levels",
	  "explanation": "This code implements an AI opponent for a Pong game, capable of adjusting its difficulty level (easy, medium, hard) based on the player's skill. The AI uses a combination of reaction delays, prediction errors, and random factors to simulate human-like behavior. The AI opponent's paddle movement is determined by predicting the ball's trajectory and adjusting its position accordingly. The difficulty levels affect how quickly the AI reacts to the ball and how accurately it predicts its path. The AI can also introduce randomness in its movements to make it less predictable at lower difficulty levels. This implementation provides a challenging yet fair experience for players of all skill levels."
	},
	"game_state": {
	  "language": "javascript",
	  "filename": "game_state.js",
	  "code": "export class GameState {\n  constructor(canvas, settings) {\n    this.canvas = canvas;\n    this.settings = settings;\n    this.leftPaddle = { x: 0, y: (canvas.height - settings.paddleHeight) / 2, width: settings.paddleWidth, height: settings.paddleHeight };\n    this.rightPaddle = { x: canvas.width - settings.paddleWidth, y: (canvas.height - settings.paddleHeight) / 2, width: settings.paddleWidth, height: settings.paddleHeight };\n    this.ball = { x: canvas.width / 2, y: canvas.height / 2, radius: settings.ballRadius, velocityX: 0, velocityY: 0 };\n    this.leftScore = 0;\n    this.rightScore = 0;\n    this.gameOver = false;\n    this.paused = false;\n    this.maxScore = settings.maxScore || 5;\n    this.deltaTime = 0;\n    this.lastTime = Date.now();\n  }\n\n  reset() {\n    // Reset game state\n    this.leftPaddle.y = (this.canvas.height - this.settings.paddleHeight) / 2;\n    this.rightPaddle.y = (this.canvas.height - this.settings.paddleHeight) / 2;\n    this.ball.x = this.canvas.width / 2;\n    this.ball.y = this.canvas.height / 2;\n    this.ball.velocityX = Math.random() < 0.5 ? -this.settings.ballSpeed : this.settings.ballSpeed;\n    this.ball.velocityY = Math.random() * 2 - 1; // Random vertical speed\n    this.gameOver = false;\n    this.paused = false;\n    \n    // Reset scores\n    this.leftScore = 0;\n    this.rightScore = 0;\n  }\n\n  update() {\n    if (this.paused || this.gameOver) return;\n\n    const now = Date.now();\n    const elapsedTime = now - this.lastTime;\n\n    // Update delta time for smooth movement\n    if (elapsedTime > 0) {\n      this.deltaTime += elapsedTime / (1000 / 60); // Assuming a target frame rate of 60 FPS\n      if (this.deltaTime > 1) this.deltaTime = 1; // Clamp to avoid large jumps\n    }\n\n    // Update ball position\n    this.ball.x += this.ball.velocityX * this.deltaTime;\n    this.ball.y += this.ball.velocityY * this.deltaTime;\n\n    // Check for wall collisions\n    if (this.ball.y <= 0 || this.ball.y >= this.canvas.height) {\n      this.ball.velocityY *= -1; // Reverse Y velocity on collision\n    }\n\n    // Check for paddle collisions\n    if (this._checkPaddleCollision(this.leftPaddle) || this._checkPaddleCollision(this.rightPaddle)) {\n      this.ball.velocityX *= -1; // Reverse X velocity on collision\n    }\n\n    // Check for scoring conditions\n    if (this.ball.x < 0) {\n      this.rightScore++;\n      if (this.rightScore >= this.maxScore) {\n        this.gameOver = true;\n      } else {\n        this.reset();\n      }\n    } else if (this.ball.x > this.canvas.width) {\n      this.leftScore++;\n      if (this.leftScore >= this.maxScore) {\n        this.gameOver = true;\n      } else {\n        this.reset();\n      }\n    }\n\n    // Update last time for next frame\n    this.lastTime = now;\n  }\n\n  _checkPaddleCollision(paddle) {\n    return (\n      this.ball.x + this.ball.radius > paddle.x &&\n      this.ball.x - this.ball.radius < paddle.x + paddle.width &&\n      this.ball.y + this.ball.radius > paddle.y &&\n      this.ball.y - this.ball.radius < paddle.y + paddle.height\n    );\n  }\n}\n",
	  "highlight_lines": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26],
	  "title": "Game State Management",
	  "description": "Game state management for a Pong game",
	  "explanation": "This code implements the game state management for a Pong game, including the initialization of paddles, ball, and scores. The GameState class handles the game loop, updating the positions of the ball and paddles based on user input and AI logic. It also manages scoring conditions, checking for collisions with paddles and walls, and resetting the game state when a player scores. The game supports pausing and resuming, as well as setting a maximum score to win. The implementation ensures smooth gameplay by using delta time to adjust movement based on frame rate."
	}
  },
  "galleries": [
    {
      "name": "GIFS",
      "description": "GIFS showing some of the projects aspects",
      "order": 1,
      "images": [
        {
          "image": "projects/ft_transcendence/demo_lobby.gif",
          "caption": "First things the user sees when getting on the site, the lobby",
          "order": 1
        },
        {
          "image": "projects/ft_transcendence/demo-42Oauth.gif",
          "caption": "OAuth2 authentication with 42 API",
          "order": 2
        },
        {
          "image": "projects/ft_transcendence/match.gif",
          "caption": "Match creation",
          "order": 3
        },
        {
          "image": "projects/ft_transcendence/demo-match_vs_IA.gif",
          "caption": "Match against the IA",
          "order": 4
        }
      ]
    },
	{
	"name": "Images",
	"description": "PNGs showing some of the projects aspects",
	"order": 2,
	"images": [
		{
		"image": "projects/ft_transcendence/lobby1.png",
		"caption": "First things the user sees when getting on the site, the lobby",
		"order": 1
		},
		{
		"image": "projects/ft_transcendence/login.png",
		"caption": "Image showing the login page",
		"order": 2
		},
		{
		"image": "projects/ft_transcendence/playscreen.png",
		"caption": "The screen where the matchs take place",
		"order": 3
		},
		{
		"image": "projects/ft_transcendence/redirect.png",
		"caption": "The page that asks the player to move to the plascreen",
		"order": 4
		},
		{
		"image": "projects/ft_transcendence/signup.png",
		"caption": "Signup page",
		"order": 5
		},
		{
		"image": "projects/ft_transcendence/workstation_pc_in_lobby.png",
		"caption": "The computer in the lobby where the sign in, signup etc. take place",
		"order": 6
		}
	]
	}
  ],
  "thumbnail": "projects/ft_transcendence/Screenshot.png",
  "architecture_diagram": "graph TD;\nA[User Input] --> B[Lexer/Parser];\nB --> C{Command Type};\nC -->|Built-in| D[Execute Built-in];\nC -->|External| E[Fork Process];\nE --> F[execve()];\nD --> G[Return to Prompt];\nF --> G;\nB --> H[Process Redirections];\nH --> C;\nB --> I[Process Pipes];\nI --> J[Create Pipe FDs];\nJ --> E;",
  "diagram_type": "MERMAID"
}]